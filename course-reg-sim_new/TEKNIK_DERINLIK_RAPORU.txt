╔════════════════════════════════════════════════════════════════════════════╗
║              TEKNİK DERİNLİK RAPORU: VERİ YAPILARI VE ALGORİTMALAR          ║
║        Üniversite Ders Kayıt ve Çakışma Çözümleme Sistemi                   ║
╚════════════════════════════════════════════════════════════════════════════╝


BÖLÜM 1: VERİ YAPILARI
═════════════════════════════════════════════════════════════════════════════

1.1 COURSE (DERS) NESNESI
─────────────────────────

Tanım:
  const course = {
    code: "YZM0205",                  // Primary Key (string)
    name: "Veri Yapıları",            // string
    dept: "Yapay Zeka ve Makine Öğrenme", // string
    capacity: 60,                     // number (kontenjan)
    scheduleStrings: [                // string[]
      "Salı 10:00-12:00"
    ],
    schedule: [                       // object[] (parse edilmiş)
      {
        day: "Salı",
        startMin: 600,    // 10:00 = 10*60 = 600 dakika
        endMin: 720,      // 12:00 = 12*60 = 720 dakika
        raw: "Salı 10:00-12:00"
      }
    ],
    prereqs: ["MAT0291", "MAT0295"],  // string[]
    enrolledStudentIds: Set,          // Set<string> - kaydolmuş öğrenciler
    waitlistStudentIds: []            // string[] - bekleme listesi
  };

Seçim Nedenleri:

✓ enrolledStudentIds = Set<string>
  • Operasyon: O(1) has(), add(), delete()
  • Sebep: Kursu kaydı kontrol hızlı olmalı
  • Örnek: course.enrolledStudentIds.has(studentId)
  
  KARŞILAŞTIRMA:
    Array:  O(n) indexOf() → 60 öğrenci = 60 kontrol
    Set:    O(1) has()   → 60 öğrenci = 1 kontrol (hızlı!)

✓ waitlistStudentIds = Array<string>
  • Operasyon: O(n) lookup, ancak sıra önemli
  • Sebep: FIFO (First In First Out) prensibine uymalı
  • Örnek: En eski talep en önce
  
  KARŞILAŞTIRMA:
    Set:    Sıra garantisi yok
    Array:  FIFO sırası garantili (index tutmuş)

✓ schedule = Object[] (pre-parsed)
  • Depolanır: { day, startMin, endMin, raw }
  • Sebep: Runtime'da parser çalıştırmasın
  • Avantaj: findConflicts() çağrısında O(1) erişim
  
  ZAMAN KAZANCI:
    parseScheduleString("Salı 10:00-12:00") → O(1) cache
    100 ders × 1000 öğrenci = 100,000 kontrol
    Parse olmasa: 100,000 × 20ms = 2000ms
    Parse olsa:  100,000 × 1ms = 100ms


1.2 STUDENT (ÖĞRENCI) NESNESI
──────────────────────────────

Tanım:
  const student = {
    id: "S0001",                  // Primary Key (string)
    classYear: 4,                 // number (1-4) - sınıf seviyesi
    remainingCourses: 3,          // number - mezuniyete kalan ders
    gpa: 3.85,                    // number (2.00-4.00) - not ortalaması
    completedCourses: Set,        // Set<string> - tamamlanan dersler
    cart: [                       // object[] - talep listesi
      { code: "YZM0205", required: true, rank: 0 },
      { code: "MAT0291", required: false, rank: 1 }
    ],
    special: {
      doubleMajor: false,         // boolean
      scholarship: true           // boolean
    }
  };

Seçim Nedenleri:

✓ completedCourses = Set<string>
  • Operasyon: O(1) has()
  • Sebep: Ön şart kontrolünde sürekli sorgulanır
  • Örnek: if (completedCourses.has("MAT0291")) { ... }

✓ cart = Array<object> (NOT Set)
  • Operasyon: O(n) forEach, O(1) random access
  • Sebep: Sıra önemli (simülasyon sırası = kayıt sırası)
  • Yapı:
    - code: ders kodu
    - required: kullanıcı tarafından işaretlenmiş mi?
    - rank: sıra numarası (admin tarafından güncellenebilir)
  
  NEDEN ARRAY:
    • Indexing avantajı: cart[0] = ilk talep (en yüksek öncelik)
    • Döngü kolaylığı: for (const item of cart)
    • Set olsaydı: sıra kaybedilirdi!


1.3 STORE (GLOBAL DEPO) NESNESI
────────────────────────────────

Tanım:
  const store = {
    coursesByCode: Map,         // Map<code: string, course: object>
    requiredCourseCodes: Set,   // Set<string> - zorunlu dersler
    students: Map,              // Map<id: string, student: object>
    lastSimulation: {           // object (caching)
      metrics: { ... },
      students: [ ... ],
      courses: [ ... ]
    }
  };

Seçim Nedenleri:

✓ coursesByCode = Map<string, object>
  • Operasyon: O(1) get(code), O(1) set(code, course)
  • Sebep: Ders bulma milyon kez yapılır
    - Simülasyon: 1000 öğrenci × 6-8 ders = 6000-8000 lookup
    - Katalog arama: binary olmadığı için linear yine O(n)
    - Konflikt kontrol: O(n) but cached schedules
  
  ZAMAN KAZANCI (1000 iteration):
    Array + indexOf: 1000 × 60 (avg) = 60,000 kontrol
    Map + get:      1000 × 1 = 1,000 kontrol (60x hızlı!)

✓ requiredCourseCodes = Set<string>
  • Operasyon: O(1) has(code)
  • Sebep: "Bu ders zorunlu mu?" çok sorgulanır
  • Örnek: if (store.requiredCourseCodes.has("YZM0205")) { ... }

✓ lastSimulation = object (caching)
  • Depolanır: Simülasyonun son sonucu
  • Sebep: Dashboard tekrar sorgulamıyor (O(1) erişim)
  • Avantaj: GET /api/simulate/last anında dönüyor
  
  AVANTAJ:
    Veritabanı sorgusu: 100ms
    Bellekten okuma: 1ms (100x hızlı!)


1.4 METRICSLER NESNESI
──────────────────────

Tanım:
  const metrics = {
    totalDemanded: 7500,                // Toplam talep edilen ders
    totalApproved: 5230,                // Toplam onaylanan ders
    fullCoursesCount: 42,               // Kontenjanı dolan ders sayısı
    rejectedByCapacity: 890,            // Kapasite nedeniyle reddedilen
    rejectedByConflict: 1120,           // Çakışma nedeniyle reddedilen
    rejectedByPrereq: 260,              // Ön şart nedeniyle reddedilen
    avgApprovedPerStudent: 5.23,        // Ortalama onaylanan/öğrenci
    overallSuccessRate: 69.73,          // Başarı oranı (%)
    mandatoryCourseSuccessRate: 92.4    // Zorunlu ders başarısı (%)
  };

Formüller:

  avgApprovedPerStudent = totalApproved / studentCount
  
  overallSuccessRate = (totalApproved / totalDemanded) * 100
  
  mandatoryCourseSuccessRate = 
    (totalMandatoryApproved / totalMandatoryDemanded) * 100

Yorum:
  • Success Rate 69.73% → Sistem doygun (talep > kapasite)
  • Zorunlu ders başarısı 92.4% → İyi (çoğu zorunlu alıyor)
  • Capacity reddi > conflict reddi → Kontenjan sorunu


─────────────────────────────────────────────────────────────────────────────


BÖLÜM 2: TEMEL ALGORİTMALAR
═════════════════════════════════════════════════════════════════════════════

2.1 ÖN ŞART KONTROLü (DFS - DERINLIK ÖNCE ARAMA)
──────────────────────────────────────────────────

Amaç:
  Öğrencinin bir dersi alabilmesi için gereken tüm ön şartları kontrol et
  (sadece 1 seviye değil, zincir halinde)

Algoritma:
  
  function missingPrereqsForCourse(store, courseCode, 
                                   completedCourses, 
                                   thisTermRequested) {
    const visited = new Set();       // Döngü önleme (ör: A→B→A)
    const missing = new Set();       // Eksik dersler
    
    function dfs(code) {
      if (visited.has(code)) return; // Ziyaret ettiyse dön
      visited.add(code);              // Şu an ziyaret ediyoruz
      
      const course = store.coursesByCode.get(code);
      if (!course) return;            // Kurs yoksa dön
      
      // Tüm ön şartlar için kontrol yap
      for (const pre of course.prereqs || []) {
        // Ön şart sağlanmış mı?
        const satisfied = 
          completedCourses.has(pre) ||      // Tamamlamış
          thisTermRequested.has(pre);       // Bu dönem almış
        
        if (!satisfied) {
          missing.add(pre);           // Eksik olarak kayıt et
          dfs(pre);                   // Öncülü de kontrol et (ZİNCİR)
        }
      }
    }
    
    dfs(courseCode);
    return Array.from(missing);
  }

Örnek 1: Basit Durum
  ────────────────
  Kurs: CALCULUS₂
  Ön Şart: [CALCULUS₁]
  
  CALCULUS₁ Ön Şart: [ALGEBRA]
  
  Öğrenci Durumu:
    completedCourses = {ALGEBRA}
    thisTermRequested = {CALCULUS₂, CALCULUS₁}
  
  Çalışma:
    1. dfs(CALCULUS₂)
       → CALCULUS₁ ön şart
       → thisTermRequested'de var (satisfied)
       → missing'e ekleme
    
    2. return [] (boş = hepsi tamam)

Örnek 2: Zincir Durum
  ────────────────
  Kurs: DATABASE
  Ön Şart: [PROGRAMMING₂]
  
  PROGRAMMING₂ Ön Şart: [PROGRAMMING₁]
  PROGRAMMING₁ Ön Şart: [LOGIC]
  
  Öğrenci Durumu:
    completedCourses = {} (hiçbiri)
    thisTermRequested = {DATABASE}
  
  Çalışma:
    1. dfs(DATABASE)
       → PROGRAMMING₂ ön şart
       → !satisfied → missing.add(PROGRAMMING₂)
       → dfs(PROGRAMMING₂)
          → PROGRAMMING₁ ön şart
          → !satisfied → missing.add(PROGRAMMING₁)
          → dfs(PROGRAMMING₁)
             → LOGIC ön şart
             → !satisfied → missing.add(LOGIC)
             → dfs(LOGIC)
                → ön şart yok → return
    
    2. return [PROGRAMMING₂, PROGRAMMING₁, LOGIC]
       (3 eksik ders)

Zaman Karmaşıklığı:
  
  O(C + P) 
  
  C = kurs sayısı (visited sınırlaması)
  P = toplam ön şart bağlantısı
  
  Örnek:
    50 kurs, her birinin 2 ön şartı = 100 bağlantı
    Worst case: O(50 + 100) = O(150) ≈ O(1) (sabit)

Avantajlar:
  ✓ Döngü yok (visited set)
  ✓ Zincir otomatik takip edilir
  ✓ Tüm eksikler bir çeşit bulunur


2.2 ÇAKIŞMA TESPITI (SCHEDULE OVERLAPPING)
────────────────────────────────────────────

Amaç:
  İki dersin gün-saat olarak çakışıp çakışmadığını tespit et

Algoritma:

  function findConflicts(currentScheduleArr, newCourseScheduleArr) {
    const conflicts = [];
    
    // Tüm mevcut-yeni dersleri karşılaştır
    for (const s1 of currentScheduleArr) {      // Mevcut
      for (const s2 of newCourseScheduleArr) {  // Yeni
        // Gün kontrolü
        if (s1.day === s2.day) {
          // Saat çakışması kontrolü
          if (overlaps(s1, s2)) {
            conflicts.push({
              day: s1.day,
              range: `${minToHHMM(Math.max(s1.startMin, s2.startMin))}-
                      ${minToHHMM(Math.min(s1.endMin, s2.endMin))}`
            });
          }
        }
      }
    }
    
    return conflicts;
  }
  
  // Helper: Saat çakışması mı?
  function overlaps(a, b) {
    // Gün aynı varsayılıyor
    return a.startMin < b.endMin && b.startMin < a.endMin;
  }

Overlaps Mantığı (Interval Overlap):
  
  ┌─────────────────── Durum 1: Çakışma VAR ────────────────────┐
  │                                                              │
  │  Mevcut:   A1 ─────────────── A2                           │
  │  Yeni:             B1 ──────────────── B2                  │
  │                                                              │
  │  Kontrol: A1 < B2 && B1 < A2                               │
  │           10 < 14 && 12 < 12:00 = TRUE                     │
  │                                                              │
  └──────────────────────────────────────────────────────────────┘

  ┌─────────────────── Durum 2: Çakışma YOK ─────────────────────┐
  │                                                               │
  │  Mevcut:   A1 ────────── A2                                 │
  │  Yeni:                          B1 ────────── B2            │
  │                                                               │
  │  Kontrol: A1 < B2 && B1 < A2                                │
  │           10 < 14 && 14 < 12 = FALSE (B1 = A2)             │
  │                                                               │
  └────────────────────────────────────────────────────────────────┘

  ┌─────────────────── Durum 3: Aynı Saat ───────────────────────┐
  │                                                               │
  │  Mevcut:   A1 ────────── A2                                 │
  │  Yeni:     B1 ────────── B2                                 │
  │                                                               │
  │  Kontrol: A1 < B2 && B1 < A2                                │
  │           10 < 12 && 10 < 12 = TRUE (ÇAKIŞMA)              │
  │                                                               │
  └────────────────────────────────────────────────────────────────┘

Örnek:
  
  Mevcut Dersler:
    CALCULUS:  Pazartesi 09:00-10:30 (540-630 dakika)
    PHYSICS:   Salı 14:00-16:00 (840-960 dakika)
  
  Yeni Ders:
    STATISTICS: Pazartesi 10:00-12:00 (600-720 dakika)
  
  Kontrol:
    CALCULUS vs STATISTICS:
      - Gün: Pazartesi = Pazartesi ✓
      - Overlaps: 540 < 720 && 600 < 630 = TRUE ✓
      → ÇAKIŞMA! (10:00-10:30 aralığında)
    
    PHYSICS vs STATISTICS:
      - Gün: Salı ≠ Pazartesi ✗
      → Çakışma yok
  
  Sonuç: Conflict = [{ day: "Pazartesi", range: "10:00-10:30" }]

Zaman Karmaşıklığı:
  
  O(A × N)
  
  A = onaylanan ders sayısı (~3-4)
  N = yeni ders schedule sayısı (~1-2)
  
  Pratikte: O(1) ~ O(4) = Sabit zaman


2.3 ÇAKIŞMA ÇÖZÜMLEME (CONFLICT RESOLUTION)
─────────────────────────────────────────────

Amaç:
  Çakışma tespit edildiğinde, hangi dersin kalıp hangisinin gitmesi 
  gerektiğine karar ver

Algoritma:

  // Simülasyon içinde...
  for (const item of student.cart) {
    const newCourse = store.coursesByCode.get(item.code);
    const conflicts = findConflicts(scheduleAccum, newCourse.schedule);
    
    if (conflicts.length) {
      const newIsMandatory = isCourseMandatory(store, item.code);
      const newIsRequired = newIsMandatory || item.required;
      
      // Çakışan onaylanan dersi bul
      const conflictingOldCode = findFirstConflictingApproved(
        store, approved, newCourse
      );
      
      if (conflictingOldCode) {
        const oldIsMandatory = isCourseMandatory(store, conflictingOldCode);
        const oldIsRequired = oldIsMandatory || 
                             isStudentMarkedRequired(student, conflictingOldCode);
        
        // Karar Ağacı
        if (oldIsMandatory && newIsMandatory) {
          // Her ikisi zorunlu → sepet sırasına güven (eski kal)
          rejected.push({ code: item.code, reason: "CONFLICT_REQUIRED_REQUIRED" });
        } else if (newIsRequired && !oldIsRequired) {
          // Yeni required, eski değil → eski drop
          dropApprovedCourse(store, student, approved, scheduleAccum, conflictingOldCode);
          // Yeni eklemeye devam et (capacity kontrol sonra)
        } else {
          // Diğer durumlar → eski kal, yeni reject
          rejected.push({ code: item.code, reason: "CONFLICT" });
        }
      }
    }
  }

Karar Tablosu:

  ┌────────────────┬────────────────┬───────────────────────────────┐
  │ Yeni Required? │ Eski Required? │ Karar                         │
  ├────────────────┼────────────────┼───────────────────────────────┤
  │ EVET           │ EVET           │ Eski Kal (Sepet Sırası)       │
  │ EVET           │ HAYIR          │ Eski Drop, Yeni Ekle          │
  │ HAYIR          │ EVET           │ Eski Kal, Yeni Reddedilir    │
  │ HAYIR          │ HAYIR          │ Eski Kal, Yeni Reddedilir    │
  └────────────────┴────────────────┴───────────────────────────────┘

Örnek:

  Senaryo 1: Zorunlu vs Seçmeli
  ────────────────────────────
  
  Mevcut (Onaylanan):
    CALCULUS (seçmeli, user-required: false)
    Pazartesi 09:00-10:30
  
  Yeni Talep:
    MATHEMATICS₁ (zorunlu)
    Pazartesi 10:00-11:30
  
  Çakışma: Pazartesi 10:00-10:30
  
  Karar: MATHEMATICS₁ zorunlu, CALCULUS değil
    → CALCULUS drop
    → MATHEMATICS₁ ekle
    → Onaylı: [MATHEMATICS₁]

  Senaryo 2: Zorunlu vs Zorunlu
  ────────────────────────────
  
  Mevcut (Onaylanan):
    MATHEMATICS₁ (zorunlu)
    Pazartesi 09:00-10:30
  
  Yeni Talep:
    PHYSICS (zorunlu)
    Pazartesi 10:00-11:30
  
  Çakışma: Pazartesi 10:00-10:30
  
  Karar: Her ikisi zorunlu → sepet sırası
    → MATHEMATICS₁ ilk, PHYSICS ikinci
    → MATHEMATICS₁ kal
    → PHYSICS reddedilir (conflict_required_required)


─────────────────────────────────────────────────────────────────────────────


BÖLÜM 3: KAYIT SIMÜLASYONU AKIŞI
═════════════════════════════════════════════════════════════════════════════

3.1 SIMÜLASYON PSEUDO-KODU
──────────────────────────

  function runSimulation(store) {
    // 1. RESET: Tüm dersler temizlen
    for (const course of store.coursesByCode.values()) {
      course.enrolledStudentIds = new Set();
      course.waitlistStudentIds = [];
    }
    
    // 2. SORT: Öğrencileri önceliğe göre sırala
    const students = Array.from(store.students.values());
    students.sort((a, b) => priority(b) - priority(a)); // DESC
    
    // 3. ITERATE: Her öğrenci için
    const results = [];
    for (const student of students) {
      const approved = [];
      const rejected = [];
      const scheduleAccum = [];
      
      // 4. PROCESS CART: Sepetteki her ders
      for (const item of student.cart || []) {
        const course = store.coursesByCode.get(item.code);
        if (!course) {
          rejected.push({ code: item.code, reason: "NOT_FOUND" });
          continue;
        }
        
        // 4a. PREREQ CHECK
        const missing = missingPrereqsForCourse(...);
        if (missing.length) {
          rejected.push({ code: item.code, reason: "PREREQ_MISSING", missing });
          continue;
        }
        
        // 4b. CONFLICT CHECK
        const conflicts = findConflicts(scheduleAccum, course.schedule);
        if (conflicts.length) {
          // Çakışma çözümü yap (yukarıdaki algoritma)
          if (/* çakışma çözüldüyse */) {
            // 4c'ye devam et
          } else {
            rejected.push({ code: item.code, reason: "CONFLICT" });
            continue;
          }
        }
        
        // 4c. CAPACITY CHECK
        if (course.enrolledStudentIds.size >= course.capacity) {
          rejected.push({ code: item.code, reason: "CAPACITY_FULL" });
          continue;
        }
        
        // 4d. ENROLL
        course.enrolledStudentIds.add(student.id);
        approved.push(item.code);
        for (const s of course.schedule) {
          scheduleAccum.push(s);
        }
      }
      
      // 5. SAVE RESULT
      results.push({
        id: student.id,
        approved,
        rejected,
        totalDemanded: approved.length + rejected.length,
        successCount: approved.length
      });
    }
    
    // 6. METRICS
    finalizeMetrics(metrics, store, results);
    
    // 7. RETURN
    return {
      metrics,
      students: results,
      courses: [...store.coursesByCode.values()]
    };
  }

3.2 YAPCAN KARAR AĞACI
──────────────────────

  Öğrenci Seçi Ders X:
  │
  ├─ Dersi Bul?
  │  ├─ HAYIR → REJECT (COURSE_NOT_FOUND)
  │  └─ EVET ↓
  │
  ├─ Ön Şart Tamam?
  │  ├─ HAYIR → REJECT (PREREQ_MISSING: [list])
  │  └─ EVET ↓
  │
  ├─ Çakışma Var?
  │  ├─ HAYIR ↓
  │  └─ EVET → Çakışma Çözümü
  │      ├─ Çözmüşse → Devam
  │      └─ Çözemezse → REJECT (CONFLICT)
  │
  ├─ Kontenjan Boş?
  │  ├─ HAYIR → REJECT (CAPACITY_FULL)
  │  └─ EVET ↓
  │
  └─ KAYDETiL
     ├─ enrolledStudentIds.add(studentId)
     ├─ approved.push(code)
     └─ scheduleAccum.push(...course.schedule)

3.3 ZAMAN KARMAŞIKLIĞI
──────────────────────

  Total: O(S × C × (1 + P + A × D + 1))
  
  Burada:
    S = Student count (1000)
    C = Cart size per student (6-8)
    P = Prereq chain length (2-3)
    A = Approved courses (3-4)
    D = Days per course (1-2)
  
  Calculation:
    1000 × 7 × (1 + 2.5 + 3.5 × 1.5 + 1)
    = 1000 × 7 × 9.25
    = ~65,000 işlem
  
  CPU Time:
    65,000 × 0.002ms = 130ms (veya daha az)

3.4 PARALLELIZATION (GELİŞTİRME)
────────────────────────────────

Şu an: Single-threaded (sırasıyla)
Gelecek: Parallelizable

  Neden parallelizable?
    • Öğrenciler birbirinden bağımsız
    • Ön şart kontrolü sadece öğrenci datası kullanan
    • Conflict çözümü ilk approved olana bağlı
    
  Zorluk:
    • enrolledStudentIds.add() RACE CONDITION
    • Concurrent access = Thread-safe Map gerekli
    
  Çözüm:
    • Locking (simple ama yavaş)
    • Sharding (partition per course)
    • Actor model (Erlang/Akka style)


─────────────────────────────────────────────────────────────────────────────


BÖLÜM 4: PERFORMANS ANALİZİ
═════════════════════════════════════════════════════════════════════════════

4.1 MEMORY USAGE
────────────────

Ders (Course) per Object:
  ≈ 500 bytes (code + name + schedule parsed + sets + arrays)
  
  60 kurs × 500 = 30 KB

Öğrenci (Student) per Object:
  ≈ 300 bytes (ID + profile + cart + completedCourses)
  
  1000 öğrenci × 300 = 300 KB

Total:
  ≈ 330 KB (çok az!)

4.2 QUERY PERFORMANCE
──────────────────────

Operasyon          | Karmaşıklık | Time (est.)
─────────────────────────────────────────────
coursesByCode.get()     | O(1)     | < 1ms
student lookup          | O(1)     | < 1ms
findConflicts()         | O(A×N)   | < 5ms
missingPrereqs()        | O(P)     | < 2ms
enrollment check        | O(1)     | < 1ms
─────────────────────────────────────────────

Full Simulation (1000 öğrenci):
  ≈ 100-200ms (Browser JS'de)

4.3 BOTTLENECKS
────────────────

1. searchCourses() [Katalog Arama]
   • O(n) döngü tüm kurslar
   • Çöz: Full-text index (later feature)

2. cartProcessing [Sepet Sırası]
   • Her ders için O(A×D) kontrol
   • Geçerli (A ve D zaten küçük)

3. conflictFind() [Çakışma Tespiti]
   • O(A²) worst case
   • Normal case: O(A×D) ≈ O(12) = sabit


─────────────────────────────────────────────────────────────────────────────


BÖLÜM 5: EDGE CASES VE SPECIAL HANDLING
═════════════════════════════════════════════════════════════════════════════

5.1 DÖNGÜ ÖNLEME (CYCLE PREVENTION)
───────────────────────────────────

Problem:
  A dersi ister B, B dersi ister A
  
Çözüm:
  missingPrereqsForCourse() visited Set kullanıyor
  
  dfs(A):
    visited.add(A)
    → B ister
      dfs(B):
        visited.add(B)
        → A ister
          dfs(A): ✗ already visited, return

5.2 EMPTY SCHEDULE HANDLING
───────────────────────────

Problem:
  Dersçin schedule yoksa?
  
Çözüm:
  course.schedule = [] (empty array)
  findConflicts([], ...) → [] (no conflicts)
  
  Safe!

5.3 DUPLICATE ENROLLMENT PREVENTION
────────────────────────────────────

Problem:
  Öğrenci iki kez aynı dersi alırsa?
  
Çözüm:
  Sepet UI'da duplicate izin yok (opsiyonel validation)
  Simülasyon: Set otomatik deduplicate eder
  
  enrolledStudentIds.add(studentId) // İki kez çağrılsa da OK

5.4 NULL/UNDEFINED SAFETY
──────────────────────────

Tüm critical fonksiyonlar check yapıyor:
  
  const course = store.coursesByCode.get(code);
  if (!course) {
    rejected.push({ code, reason: "COURSE_NOT_FOUND" });
    continue;
  }


─────────────────────────────────────────────────────────────────────────────


BÖLÜM 6: TESTİNG STRATEJİSİ
═════════════════════════════════════════════════════════════════════════════

6.1 UNIT TESTS (Önerilen)
──────────────────────────

1. Prerequisite Validation
   - missingPrereqsForCourse([A←B←C], {}, {}) → [B, C]
   - missingPrereqsForCourse([A←B], {B}, {}) → []

2. Conflict Detection
   - overlaps({day: "Mon", start: 10, end: 12}, 
               {day: "Mon", start: 11, end: 13}) → true
   - overlaps({day: "Mon", start: 10, end: 12},
               {day: "Tue", start: 10, end: 12}) → false

3. Priority Scoring
   - studentPriorityScore({ classYear: 4, ... }) > 
     studentPriorityScore({ classYear: 1, ... })

6.2 INTEGRATION TESTS
─────────────────────

1. Full Simulation
   - 1000 öğrenci, kontrol sonuçları
   - Metrics: totalDemanded = sum(cart.length)

2. Conflict Resolution
   - Mandatory vs Optional
   - Verify: rejected[x].reason = "CONFLICT"

3. Enrollment Integrity
   - course.enrolledStudentIds.size <= capacity


─────────────────────────────────────────────────────────────────────────────


SONUÇ
═════════════════════════════════════════════════════════════════════════════

✓ Veri Yapıları:
  • Map/Set optimal seçilmiş
  • O(1) operasyonları maksimize edilmiş
  • Memory efficiency yüksek

✓ Algoritmalar:
  • DFS: Zincir kontrolü tamam
  • Overlap: Saat çakışması doğru
  • Resolution: Kural-tabanlı, tutarlı

✓ Performans:
  • Simulation: 100-200ms (1000 öğrenci)
  • Query: < 5ms (average)
  • Memory: < 1MB

✓ Robustness:
  • Edge cases handled
  • Null safety checks
  • Cycle prevention

Sistem Production-Ready (persistence eklenirse).


Tarih: 11 Ocak 2026
Sahibi: BTU Ders Kayıt Sistemi
